{"pages":[{"title":"关于","text":"哈喽！欢迎来到我的博客，我叫JDX，一个兴趣使然的程序员，一个要成为大佬的男人！关于本博客，如果你有任何问题都可以问我，我的联系方式在最下面。也欢迎大家多多交流，共同进步！最后，希望大家都能成为自己想成为的人！ QQ：455489221Wechat：Akai4219","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"资源","text":"","link":"/resources/index.html"}],"posts":[{"title":"492.构造矩形","text":"作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求： 1231. 你设计的矩形页面必须等于给定的目标面积。2. 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。3. 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。 示例1234输入: 4输出: [2, 2]解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。 说明 给定的面积不大于 10,000,000 且为正整数。 你设计的页面的长度和宽度必须都是正整数。 题解：方法一： 我一开始想的是比较暴力的方法。双循环遍历，但是由于数据量比较大，双循环会超时，之后就舍弃了这种方法。方法二： 后来想到了从area的根开始遍历。一开始宽和高都是$ \\sqrt{ area } $，之后l++，w–就可以得到答案了。 代码： 1234567891011121314151617181920212223242526public int[] constructRectangle(int area) { int[] ans = new int[2]; int l = 0, w = 0, sub = Integer.MAX_VALUE; w = (int) Math.sqrt(area); l = (int) Math.sqrt(area); if (w * w == area) { ans[0] = w; ans[1] = w; return ans; } while (w &gt; 0) { if (w * l == area &amp;&amp; sub &gt; l - w) { ans[0] = l; ans[1] = w; break; } if (w * l &gt; area) { w--; l++; } if (w * l &lt; area) { l++; } } return ans;}附上三叶大佬的方法： 12345public int[] constructRectangle_3y(int area) { for (int i = (int) (Math.sqrt(area)); ; i--) { if (area % i == 0) return new int[]{area/i,i}; }} 太强了太强了！最后，大家努力刷题吧！","link":"/2021/10/23/20211023/"},{"title":"496.下一个更大元素Ⅰ","text":"题目：496.下一个更大元素Ⅰ给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。 示例：123456输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释: 对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。 对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。 对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。 12345输入: nums1 = [2,4], nums2 = [1,2,3,4].输出: [3,-1]解释: 对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。 对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。 题解：方法一：遍历+哈希表如果直接遍历两个数组来寻找下一个更大元素的话，相当于$ n^2 $的算法，时间复杂度比较高，又因为题目里面说nums1和nums2中的元素互不相同，所以可以用哈希表来做一个加速，首先先遍历nums2数组，把nums2中元素的值和对应的下标放到哈希表中，之后再遍历nums1数组，把找到num2对应的元素，从哈希表中得到下标，之后往后遍历寻找到第一个最大元素后跳出循环，如果没有找到，就给ans中赋值-1 12345678910111213141516171819202122public int[] nextGreaterElement(int[] nums1, int[] nums2) { int m = nums1.length,n = nums2.length; int[] ans = new int[m]; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i&lt;n;i++){ map.put(nums2[i],i); } for (int i = 0;i&lt;m;i++){ int x = nums1[i]; int j = map.get(x); for (;j&lt;n;j++){ if (nums2[j]&gt;x){ ans[i] = nums2[j]; break; } } if (ans[i]==0){ ans[i] = -1; } } return ans;} 方法二：单调栈因为我们找某个数在nums2右边比它大的第一个数，所以我们可以对nums2进行逆序遍历。我们首先遍历nums2数组，遍历的同时维护一个单调栈，当我们遍历到nums2[i]元素时，我们先将栈顶中比nums2[i]小的元素出栈。出完后有两种结果： 栈为空，说明nums2[i]右边没有比它大的元素。 栈不为空，此时栈顶元素是nums2[i]右边离他最近的元素。再利用数组中的元素各不相同，在遍历nums2时，使用哈希表记录每个元素对应的目标值是多少。12345678910111213141516class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int n = nums1.length, m = nums2.length; Deque&lt;Integer&gt; d = new ArrayDeque&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = m - 1; i &gt;= 0; i--) { int x = nums2[i]; while (!d.isEmpty() &amp;&amp; d.peekLast() &lt;= x) d.pollLast(); map.put(x, d.isEmpty() ? -1 : d.peekLast()); d.addLast(x); } int[] ans = new int[n]; for (int i = 0; i &lt; n; i++) ans[i] = map.get(nums1[i]); return ans; }}","link":"/2021/10/26/20211026/"},{"title":"638.大礼包","text":"题目：在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。 给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。 还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。 返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。 示例：123456输入：price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]输出：14解释：有 A 和 B 两种物品，价格分别为 ¥2 和 ¥5 。 大礼包 1 ，你可以以 ¥5 的价格购买 3A 和 0B 。 大礼包 2 ，你可以以 ¥10 的价格购买 1A 和 2B 。 需要购买 3 个 A 和 2 个 B ， 所以付 ¥10 购买 1A 和 2B（大礼包 2），以及 ¥4 购买 2A 。 123456输入：price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]输出：11解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。 需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。 不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。 题解：方法：记忆化搜索思路：借鉴了【微扰理论】大佬的思路，在暴力递归的基础上，加入cache哈希表作为缓存，之后进行暴力递归，如果发现当前的needs在cache中，就直接返回，如果不在，就进行暴力递归，并且找到最小的花费，最后将这次的needs加入到cache缓存中，方便下次搜索。 代码：123456789101112131415161718192021222324252627282930313233343536373839//相当于记忆化搜索的dp，就是缓存，用于记录每次找过的需求Map&lt;List&lt;Integer&gt;, Integer&gt; cache = new HashMap&lt;&gt;();public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) { return dfs(needs, price, special);}public int dfs(List&lt;Integer&gt; needs, List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special) { //如果以前计算过这个needs，就直接返回 if (cache.containsKey(needs)) return cache.get(needs); int ans = 0; //最简单的方法，不买礼包， for (int i = 0; i &lt; needs.size(); i++) { ans += needs.get(i) * price.get(i); } //遍历和购买每个礼包，找到最便宜的价格 for (int i = 0; i &lt; special.size(); i++) { List&lt;Integer&gt; next = new ArrayList&lt;&gt;(needs); boolean flag = true; for (int item = 0; item &lt; price.size(); item++) { //购买数量不能超过needs，所以，如果礼包里面物品的数量大于了needs里面对应物品的数量就不买这个大礼包 if (special.get(i).get(item) &gt; needs.get(item)) { flag = false; break; } } //大礼包不符合要求，跳过这个大礼包，不购买 if (!flag) continue; //当前大礼包符合要求，用next数组记录购买这个大礼包后，还需要各种物品的数量，并带入next基于递归 for (int item = 0; item &lt; price.size(); item++) { next.set(item, next.get(item) - special.get(i).get(item)); } //在所有的购买方法中找到最便宜的方法 ans = Math.min(ans, dfs(next, price, special) + special.get(i).get(price.size())); } //递归结束后，更新我们的cache缓存，便于后面再次查找 cache.put(needs, ans); return ans;}","link":"/2021/10/24/20211024/"},{"title":"301.删除无效的括号","text":"题目：301.删除无效的括号给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。答案可以按 任意顺序 返回。 示例：12输入：s = &quot;()())()&quot;输出：[&quot;(())()&quot;,&quot;()()()&quot;] 12输入：s = &quot;(a)())()&quot;输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;] 12输入：s = &quot;)(&quot;输出：[&quot;&quot;] 题解：今天是一道括号匹配的题目，题目要求输出有效并且最长的字符串，所以没有别的方法，只能回溯搜索+剪枝，每次遇到括号都有两种情况，选和不选，遇到字母就放入字符串中，不过要先遍历一次给的字符串，确定要删除多少左括号和删除多少有括号，确定最终有效字符串的长度。 123456789101112131415161718192021222324252627282930313233343536373839HashSet&lt;String&gt; help = new HashSet&lt;&gt;();public List&lt;String&gt; removeInvalidParentheses(String s) { String s1 = &quot;&quot;; int r = 0,l = 0; for (int i = 0;i&lt;s.length();i++){ if (s.charAt(i)=='(') l++; //l表示删除左括号的数量 if (s.charAt(i)==')'){ l--; if (l&lt;0){ r++;//r表示删除右括号的数量 l = 0; } } } int x = t+l; //x表示删除括号的总和 dfs(s,0,0,s1,x); return new ArrayList&lt;&gt;(help);}public void dfs(String s,int index,int x,String s1,int t){ if (index&gt;=s.length()){ if (x==0&amp;&amp;s1.length()==s.length()-t&amp;&amp;!help.contains(s1)){ help.add(s1); } return ; } if (x&lt;0){ return ; } if (s.charAt(index)=='('){ dfs(s,index+1,x,s1,t); dfs(s,index+1,x+1,s1+&quot;(&quot;,t); }else if (s.charAt(index)==')'){ dfs(s,index+1,x,s1,t); dfs(s,index+1,x-1,s1+&quot;)&quot;,t); }else{ dfs(s,index+1,x,s1+s.charAt(index),t); }} 下面是三叶大佬的方法，她在遍历的过程中进行了剪枝，所以效率要高很多，学习了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445Set&lt;String&gt; set = new HashSet&lt;&gt;();int n,max,len;String s;public List&lt;String&gt; removeInvalidParentheses(String _s) { s = _s; n = s.length(); int l = 0,r = 0; int c1 = 0,c2=0; for (char c:s.toCharArray()){ if (c=='('){ c1++; l++; }else if(c==')'){ c2++; if (l!=0) l--; else r++; } } //l，r分别表示需要删除的左右括号的数量 //len代表最终字符串的长度 len = n-l-r;//c1 c2 分别代表左/右括号的数量，要想做到括号匹配，最终匹配的数量等于少的那一个的数量 max = Math.min(c1,c2); dfs(0,&quot;&quot;,l,r,0); return new ArrayList&lt;&gt;(set);}public void dfs(int u,String cur,int l,int r,int score){ //如果不符合要求了就直接返回，进行剪枝！！！加速操作！！！ if (l&lt;0||r&lt;0||score&lt;0||score&gt;max) return ; if (l==0&amp;&amp;r==0){ //如果左右括号都删完了，并且长度也满足要求，就说明是有效字符串 if (cur.length()==len) set.add(cur); } //如果到了最后也没有满足要求，也返回 if (u==n) return ; char c = s.charAt(u); if (c=='('){ dfs(u+1,cur+String.valueOf(c),l,r,score+1); dfs(u+1,cur,l-1,r,score); }else if (c==')'){ dfs(u+1,cur+String.valueOf(c),l,r,score-1); dfs(u+1,cur,l,r-1,score); }else dfs(u+1,cur+String.valueOf(c),l,r,score);} 后记：今天第一次自己A出了困难题（虽然也不太难），但是也是值得庆祝的一天，这是向大佬迈出的第一步，开心！！！！","link":"/2021/10/27/20211027/"},{"title":"240.搜索二维矩阵 Ⅱ","text":"题目：编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。每列的元素从上到下升序排列。 示例：12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5输出：true 12输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20输出：false 题解：方法一：遍历整个二维数组，如果找到target返回true，如果没找到就返回false，由于这道题二维数组的长和宽最大是300，所以最大数据量是90000，不是很大，所以遍历这种暴力方法也能accept。但是不推荐用这种方法，没有什么算法可言。 12345678910public boolean searchMatrix_bl(int[][] matrix, int target) { int m = matrix.length,n = matrix[0].length; for (int i = 0;i&lt;m;i++){ for (int j = 0;j&lt;n;j++){ if (matrix[i][j]==target) return true; } } return false;} 方法二： 二分查找，但是这道题和搜索二维数组Ⅰ不一样的地方是，这道题的数组并不保证第二行都大于第一行，所以没办法用两次二分的方式，需要对每一行/列进行二分，如果找到了就返回true，如果遍历了所有行/列都没找到，那么就返回false。 12345678910111213public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length,n = matrix[0].length; for (int i = 0;i&lt;m;i++){ int l = 0, r = n-1; while(l&lt;r){ int mid = (l+r+1)&gt;&gt;1; if (matrix[i][mid]&lt;=target) l = mid; else r = mid-1; } if (matrix[i][r]==target) return true; } return false;} 方法三： 参考宫水三叶大佬的方法，可以把这个二维数组看成搜索二叉树（BST），右上角作为根节点，同行的作为左子树，同列的作为右子树，这样正好符合了搜索二叉树的定义，左子树上的节点都比根节点小，右子树上的节点都比根节点大。之后从右上角开始查找，如果当前节点的值比target大，就往左找，列数c–，如果当前节点的值比target小，就往下找，行数r++，如果超出了二维数组的范围还没找到，就是没有，就返回false 12345678910public boolean searchMatrix_BST(int[][] matrix, int target) { int m = matrix.length,n = matrix[0].length; int r = 0,c = n-1; while(r&lt;m&amp;&amp;c&gt;=0){ if (matrix[r][c]&lt;target) r++; else if (matrix[r][c]&gt;target) c--; else return true; } return false;}","link":"/2021/10/25/20211025/"},{"title":"869.重新排序得到2的幂","text":"题目：869.重新排序得到2的幂给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。 示例：12输入：1输出：true 12输入：10输出：false 12输入：16输出：true 12输入：24输出：false 12输入：46输出：true 题解：今天这道题自己没做出来，coding的问题，思路是对的，但是不知道怎么写（就是不会），最后看了三叶姐的题解看明白了，我一开始是想把每个排序都排出来，之后挨个检验是否是2的幂，三叶姐的解法一也是这么做的。解法一：打表+DFS首先把所有2的幂，放到set中，之后通过dfs找到所有n的序列，判断该序列在不在set中，如果在就说明有2的幂，如果都不在说明没有，返回false； 123456789101112131415161718192021222324252627class Solution { static Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); static { for (int i = 1; i &lt; (int)1e9+10; i *= 2) set.add(i); } int m; int[] cnts = new int[10]; public boolean reorderedPowerOf2(int n) { while (n != 0) { cnts[n % 10]++; n /= 10; m++; } return dfs(0, 0); } boolean dfs(int u, int cur) { if (u == m) return set.contains(cur); for (int i = 0; i &lt; 10; i++) { if (cnts[i] != 0) { cnts[i]--; if ((i != 0 || cur != 0) &amp;&amp; dfs(u + 1, cur * 10 + i)) return true; cnts[i]++; } } return false; }} 解法二：打表+词频统计通过解法一，我们发现复杂度的上届取决于对n的重排，同时数据范围内的2的幂很少。所以我们可以直接通过枚举所有2的幂x，检查x的词频和n是否相同，这样可以有效降低时间复杂度。 1234567891011121314151617181920212223242526class Solution { static Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); static { for (int i = 1; i &lt; (int)1e9+10; i *= 2) set.add(i); } public boolean reorderedPowerOf2(int n) { int[] cnts = new int[10]; while (n != 0) { cnts[n % 10]++; n /= 10; } int[] cur = new int[10]; out:for (int x : set) { Arrays.fill(cur, 0); while (x != 0) { cur[x % 10]++; x /= 10; } for (int i = 0; i &lt; 10; i++) { if (cur[i] != cnts[i]) continue out; } return true; } return false; }} 最后附上原题解的链接：宫水三叶","link":"/2021/10/28/20211028/"},{"title":"260.只出现一次的数字Ⅲ","text":"题目：260.只出现一次的数字Ⅲ给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？ 示例：123输入：nums = [1,2,1,3,2,5]输出：[3,5]解释：[5, 3] 也是有效的答案。 12输入：nums = [-1,0]输出：[-1,0] 12输入：nums = [0,1]输出：[1,0] 题解：方法一：哈希集合对于这种寻找出现次数的题目，可以统一使用哈希表或者哈希集合来做，本题使用哈希集合. 首先遍历整个数组，如果遍历到的数字没有在集合中，就把它加进去，如果已经在了就把他删除。 这样遍历完整个数组，就只剩下了我们需要的只出现一次的两个元素，我们再遍历集合，把集合中的数放到数组中。 123456789101112131415161718public int[] singleNumber(int[] nums) { int n = nums.length; if (n == 2) return nums; int[] ans = new int[2]; Set&lt;Integer&gt; help = new HashSet&lt;&gt;(); for (int i = 0; i &lt; n; i++) { if (help.contains(nums[i])) help.remove(nums[i]); else help.add(nums[i]); } int i = 0; for (int x : help) { ans[i++] = x; } return ans;} 方法二： 使用位运算异或，首先遍历整个数组进行异或，最后只剩下出现一次的两个数异或的结果sum。 之后我们取sum二进制表示中为1的任意一位k，sum中k位为一就说明只出现一次的这两个数k位是不同的。 之后我们在对nums进行遍历，我们对k位为0和为1的分别进行异或操作（两个答案因为k位不同，所以必定会被分到两个组中），就求出了答案 1234567891011121314public int[] singleNumber(int[] nums) { int sum = 0; for (int i : nums) sum ^= i; int k = -1; for (int i = 31; i &gt;= 0; i--) { if (((sum &gt;&gt; i) &amp; 1) == 1) k = i; } int[] ans = new int[2]; for (int i : nums) { if (((i &gt;&gt; k) &amp; 1) == 1) ans[1] ^= i; else ans[0] ^= i; } return ans;} PS：昨天的每日一题太难了（我不会做，不是），昨天考了近世代数，光复习了没来及的做（还是因为菜）","link":"/2021/10/30/20211030/"},{"title":"2021年度总结","text":"2021年度总结​ 2021年12月31日，晴，太阳很大，不过挺冷的，冻手。 ​ 今天是2021年的最后一天，趁此机会，总结一下我的2021。 ​ 2021年，也是被疫情笼罩的一年。今年上半年，我先是在家完成了本科毕业设计的开题工作，到了四月份就回到了学校，开始了毕业设计的制作，中间也是历经各种问题和磨难，不过最后的结果还好，我也顺利的完成了毕业答辩，顺利拿到了毕业证和学士学位证。6月18日，我毕业了，离开了生活了四年的大学。回到了家中，久违的颓废感油然而生，每天就是吃了玩儿，玩儿了吃，吃了睡。在经过了十来天的放松之后，我开始了为期两周研究生暑期课程。课程结束之后，我又回到了保定，开始再次学习驾照，经过半个多月的努力，我也是成功拿到了机动车驾驶证，从8月16日开始，我也是一名合格的司机了。 ​ 之后就到了9月，我来到了期盼已久的研究生学校—-北京邮电大学。从那时候开始，我就是一名北京邮电大学的研一学生了。刚刚进入研究生，一开始也有点不习惯，没有了本科的实验室，一时间不知道干些什么。但是为了不荒废时光，还是听从了师兄师姐的建议，开始了刷题之旅。因为本科的时候数据结构并没有学得非常好，所以一开始刷题可以说是啥都不会，一道简单题也要想好久，可能还想不出来，但是算法也不是能够速成的，所以我也不着急，自己一点一点的学，迟早能学会的，我就给自己制定了目标，每天A三道题，从最开始的0，到现在已经解决了315道题了，还写了两篇题解，我感觉已经非常的不错了。 ​ 从9月9日开始，到12月31日我一共解决了315道题，一共31+30+31+30-8=114天，平均每天解决315/114 = 2.763道题，约等于每天3道题，基本完成了最初定下的目标。到现在，大部分的题型都已经见过了，解题速度也有了很大的提高，希望自己继续坚持下去，也希望自己明年也继续加油！多多A题，多写论文！加油！ ​ 最后，也要祝自己生日快乐啦，又长大了一岁，明年一定要努力哦！！","link":"/2021/12/31/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932/"},{"title":"63.不同路径 Ⅱ","text":"题目：63.不同路径 Ⅱ63.不同路径Ⅱ 题解：一、 暴力搜索dfs 按照题目的思路，每次都让机器人往下或者往右走一个格。 如果走到障碍物上或走出边界，就说明这条路不对，就返回，如果最后走到了右下角，就让ans+1。 1234567891011121314151617class Solution{ int ans = 0; public int uniquePathsWithObstacles(int[][] obstacleGrid) { dfs(obstacleGrid, 0, 0); return ans; } public void dfs(int[][] ob, int i, int j) { if (i &gt;= ob.length || j &gt;= ob[0].length) return; if (ob[i][j] == 1) return; if (i == ob.length - 1 &amp;&amp; j == ob[0].length - 1) ans++; dfs(ob, i + 1, j); dfs(ob, i, j + 1); }} 但是这种方法走了太多的重复路径，导致时间复杂度过高，最终无法accept，会超时。所以就引出了第二个方法，在暴力搜索的基础上加上记忆化数组，进行记忆化搜索，就可以减少重复路径了 二、记忆化搜索+dfs 在方法一的基础上加上一个记忆化数组dp，保存我们每次走过的路径数，如果遇到走过的路径就直接返回。 12345678910111213141516171819202122class Solution{ int[][] dp; public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; dp = new int[m][n]; return dfs_dp(obstacleGrid, 0, 0); } public int dfs_dp(int[][] ob, int i, int j) { if (i == ob.length || j == ob[0].length) return 0; if (ob[i][j] == 1) return 0; if (i == ob.length - 1 &amp;&amp; j == ob[0].length - 1) return 1; if (dp[i][j] != 0) return dp[i][j]; dp[i][j] += dfs_dp(ob, i + 1, j) + dfs_dp(ob, i, j + 1); return dp[i][j]; }} 三、动态规划 通过记忆化搜索，其实我们已经找到了动态转移方程. 动态转移方程：dp[i][j] = dp[i+1][j]+dp[i][j+1] 所以，我们根据动态转移方程和base case就可以写出动态规划形式的代码啦。 1234567891011121314151617class Solution public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m+1][n+1]; for (int i = m-1;i&gt;=0;i--){ for (int j = n-1;j&gt;=0;j--){ if (i==m-1&amp;&amp;j==n-1&amp;&amp;obstacleGrid[i][j]==0) dp[i][j] = 1; else if (obstacleGrid[i][j]==0){ dp[i][j] = dp[i+1][j] + dp[i][j+1]; } } } return dp[0][0]; } 如果i，j超出数组范围的话就返回0，所以我让dp的大小是m+1×n+1，这样就不用判断越界的情况了，比较省事的写法。 萌新第二次更新题解，欢迎大佬在评论区提出改进，也欢迎大家多多交流！","link":"/2021/10/30/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"},{"title":"二分查找模板","text":"题目：二分查找模板代码：123456789101112131415161718public int binarySearch1(){ int l = 区间左端点, r = 区间右端点; while(l&lt;r){ int mid = l + r &gt;&gt; 1; if(check(mid)) r = mid; else l = mid + 1; } return r;}public int binarySearch2(){ int l = 区间左端点, r = 区间右端点; while(l&lt;r){ int mid = l + r + 1&gt;&gt; 1; if(check(mid)) r = mid - 1; else l = mid; } return r;} 思路： 循环写成while(l&lt;r)，在退出循环时有r == l成立，就不用再判断是返回l，还是返回r了。 区间[l, r]的划分有以下两种情况： ① 分成[l, mid]和[mid+1, r]。分别对应r = mid 和 l = mid +1; ② 分成[l, mid-1]和[mid, r]。分别对应l = mid 和r = mid - 1，这种情况下需要把 mid = (l + r) / 2改成 mid = (l + r + 1) / 2，否则会出现死循环，当出现死循环的时候，可以把l和r的值打印以下，看一看就清楚了，不用死记硬背。 退出循环时有 r == l，如果区间 [ l , r ]内确定有解，则直接返回 l 就可以，否则还需要对l这个位置单独做一次判断。 二分查找的不变量是：在区间 [ l , r ]里查找目标元素。 check()函数是重点，需要根据题目要求，去确定我们的二分区间，根据题目进行分析即可，不需要死记硬背，多做点题就可以掌握分析的方法。","link":"/2021/11/20/Binary-Search/"},{"title":"hexo添加顶部加载进度条","text":"教程：1.进入博客的 /themes/next 目录下2.下载安装，Progress modules，输入代码如下： 12git clone git@github.com:theme-next/theme-next-pace.git source/lib/pace网上很多教程都是输入https的链接进行下载，但是现在git好像不支持https下载了，应该使用ssh进行下载。 3.打开主题配置文件，themes/next目录下的_config.yml文件，可以使用 ctrl+f搜索pace，之后将enable：false改成true，还可以更改类型（theme）： 123456pace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: minimal 最后重新部署博客就好啦。 后记：不过theme-next-pace默认的配色都是蓝色的，可能与博客的主题不搭，我通过查看css文件，找到了修改颜色的方法：1.进入themes\\next\\source\\lib\\pace目录下，找到你要是用的样式的css文件并打开，例如我使用的是loading-bar这个样式，我就打开pace-theme-loading-bar.min.css这个文件2.打开之后，使用ctrl+f搜索color，之后就会找到对应的属性，比如color：#29d，css文件使用的是十六进制的RGB值来表示颜色，一个颜色占两位，它默认的#29d代表蓝色，如果想改成黑色就把#29d改为#000000，如果想改成别的颜色可以自己去画图工具中自定义颜色，之后把分别把RGB的值转换为16进制就好了3.到上面已经完成了大部分了，现在可以试一试，发现只有进度条里面的颜色改了，但是外边框的颜色还是没有变，接下来继续修改css文件，使用ctrl+f搜索刚刚我们改之前的color属性的值，比如我就搜索#29d，之后又会找到一个属性的值是这个，把它也改为你想要的颜色，就大功告成了！","link":"/2021/10/24/hexo%E6%B7%BB%E5%8A%A0%E9%A1%B6%E9%83%A8%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1/"},{"title":"manacher算法","text":"题目：Manacher 算法算法简介： Manacher算法是一个叫Manacher的人在1975年发明的， 这个方法最大的贡献是将回文字符串匹配的时间复杂度降低到了线性。 算法流程： 首先先解决字符串奇偶不一样的问题，我们在每两个字符的中间加入一个’#’(可以不是#，只要是字符串中原来没有出现过的字符就行)，之后为了使我们在遍历匹配字符的过程中，到达边界能够自动结束，所以我们在字符串的两头分别加入’^’和’$’（同理，也可以不是这两个字符，只要是原字符串中没有出现过的字符即可）。 原理：因为奇数个字符的“空隙”一定有偶数个，偶数个字符的“空隙”一定有奇数个，所以我们这么改变字符串之后，字符串一定会变成奇数字符串，这样就解决了奇偶字符串匹配不一样的问题。 之后，我们用一个数组P来保存，以当前字符为中心，能向两边扩展的长度，也就是回文半径,而回文半径正好是去掉’#’的原字符串的总长度。举个栗子🌰： 从上图中，可以看到P[6] = 5,也就是在P[6]这个位置，可以向两边扩展5个长度的字符串，组成回文字符串，即”#c#b#c#b#c#”,去掉所有’#’后，变成了”cbcbc”，他的长度正好是回文半径的长度5。 接下来，我们就可以求出原回文字符串开头位置字符的下标了，用P的下标i减去P[i]再除以2，这是因为，前面每个字符中间都有一个’#’所以前面的字符数和’#’数相等，所以我们用当前下标减去回文半径再除以二就得到了原回文字符串开头位置的下标了。 举个例子🌰：还是上面那个图，比如我们要求P[6]对应的回文字符串开头位置的下标，我们就用（6-5）/ 2 = 0，就说明开头位置的下标是0，所以我们得到的回文子字符串的下标就是[0，5-1] = [0,4] 接下来，就到了整个算法的关键所在了，就是求P[i]，求以每个字符为中心的回文半径，在这一步充分利用了回文字符串的对称性。 我们规定，用C表示回文字符串的中心，R表示回文半径，所以R=C+P[i]，C和R所对应的回文字符串是当前循环中最靠右的回文字符串。 我们用i表示当前正在求得回文字符串的中心位置的下标，i_mirror表示i关于C对称的下标。🌰： 我们现在要求P[i]，如果使用中心扩展法，我们就直接从i往两边扩展就行了，但是这样时间复杂度太高，我们可以利用回文字符串C的对称性，i关于C的对称点是i_mirror，P[i_mirror]= 3，所以P[i]也等于3。但是有三种情况会造成给P[i]直接赋值P[i_mirror]不正确，下面一一讨论。 P[i]+P[i_mirror]&gt;R: 当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。 P [ i_mirror ] 遇到了原字符串的左边界 此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了 i 等于了 R 此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。 最后，我们考虑C和R的更新问题，我们一步一步求出P[i]之后，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public String preProcess(String s) { int n = s.length(); if (n == 0) { return &quot;^$&quot;; } String ret = &quot;^&quot;; for (int i = 0; i &lt; n; i++) ret += &quot;#&quot; + s.charAt(i); ret += &quot;#$&quot;; return ret;}// 马拉车算法public String longestPalindrome2(String s) { String T = preProcess(s); int n = T.length(); int[] P = new int[n]; int C = 0, R = 0; for (int i = 1; i &lt; n - 1; i++) { int i_mirror = 2 * C - i; if (R &gt; i) { P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R } else { P[i] = 0;// 等于 R 的情况 } // 碰到之前讲的三种情况时候，需要利用中心扩展法 while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) { P[i]++; } // 判断是否需要更新 R if (i + P[i] &gt; R) { C = i; R = i + P[i]; } } // 找出 P 的最大值 int maxLen = 0; int centerIndex = 0; for (int i = 1; i &lt; n - 1; i++) { if (P[i] &gt; maxLen) { maxLen = P[i]; centerIndex = i; } } int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标 return s.substring(start, start + maxLen);} 第一次写关于算法相关的解释，写的不好，请大佬们多多指点。本文参考了leetcode的题解，链接也放到最下面啦。作者：windliang链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/","link":"/2021/11/01/manacher%E7%AE%97%E6%B3%95/"},{"title":"Mark Text快捷键大全","text":"Mark Text快捷键大全：1.快捷键说明： 功能 快捷键 示例 一级标题 Ctrl + 1 二级标题 Ctrl + 2 三级标题 Ctrl + 3 四级标题 Ctrl + 4 五级标题 Ctrl + 5 六级标题 Ctrl + 6 加粗 Ctrl + B 加粗 倾斜 Ctrl + i 倾斜 插入表格 Ctrl + Shitf + t 侧边文件信息显示 Ctrl + j 文件保存 Ctrl + s 撤销 Ctrl + z 删除线 Ctrl + d 删除线 搜索 Ctrl + f 超链接 Ctrl + L 我的博客 插入公式 Ctrl + Shift + M $A+B$ 插入分割线 Ctrl + Alt + - 插入单行代码 Ctrl + ` System.out.println(&quot;Hello World!&quot;) 插入多行代码 Ctrl + ``` 调整字体大小 Ctrl + &gt; 插入图片 Ctrl + Shift + i","link":"/2021/12/28/marktexttip/"},{"title":"第一条当然是hexo发布博客教程啦！","text":"写在前面(没用的感概，与内容无关)：​ 历经了四五个小时的努力，终于搭建好了人生的第一个博客（现在还没有域名，不过很快就会有了！），中间的千辛万苦就不多说了，以后有的是时间说，开始干货分享吧！ 正文：​ 如题，作为第一篇博客，当然是给后人指路啦！​ 我搭建hexo博客看的教程是知乎上的，知乎链接，不过我按照上面一步一步做，中间会有问题，当要进行git操作的时候，很大可能会需要管理员权限，所以直接打开git去抄代码是不行的，需要对git右键以管理员身份运行，之后就一路畅通啦！​ 搭建好博客后，最重要的当然是发布博客啦（废话！要不然你弄个博客干啥！）​ 那下面就开始介绍啦，首先再博客根目录打开git，输入 hexo n “你博客的标题”，之后打开source/_posts目录，就可以看到你新建好的markdown文件啦，之后随便找一个markdown编辑器（我用的是Typora，别的也可以）写上自己想写的东西，保存，之后重复部署的步骤就好啦（hexo clean g d）​ 行了，时间也不早了，就到这里吧，下次再接着写！","link":"/2021/10/21/%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%BD%93%E7%84%B6%E6%98%AFhexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%E5%95%A6%EF%BC%81/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"简单模拟","slug":"简单模拟","link":"/tags/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9F/"},{"name":"单调栈","slug":"单调栈","link":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"记忆化搜索","slug":"记忆化搜索","link":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"括号匹配","slug":"括号匹配","link":"/tags/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"年度总结","slug":"年度总结","link":"/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"暴力dfs","slug":"暴力dfs","link":"/tags/%E6%9A%B4%E5%8A%9Bdfs/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"hexo教程","slug":"hexo教程","link":"/tags/hexo%E6%95%99%E7%A8%8B/"},{"name":"回文字符串","slug":"回文字符串","link":"/tags/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"manacher","slug":"manacher","link":"/tags/manacher/"},{"name":"Mark Text","slug":"Mark-Text","link":"/tags/Mark-Text/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"每日一题","slug":"每日一题","link":"/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"年度总结","slug":"年度总结","link":"/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"力扣题解","slug":"力扣题解","link":"/categories/%E5%8A%9B%E6%89%A3%E9%A2%98%E8%A7%A3/"},{"name":"刷题笔记","slug":"刷题笔记","link":"/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"hexo教程","slug":"hexo教程","link":"/categories/hexo%E6%95%99%E7%A8%8B/"},{"name":"Mark Text","slug":"Mark-Text","link":"/categories/Mark-Text/"}]}